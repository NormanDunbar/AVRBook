\chapter{Installing PlatformIO}\label{installing-platformio}

\section{PlatformIO}\label{platformio}\index{PlatformIO}

\href{http://platformio.org/}{PlatformIO} comes in two separate versions:

\begin{itemize}
	\item PlatformIO Core;
	\item PlatformIO IDE;
\end{itemize}	

There is also a debugger available. 

\program{PlatformIO Core}PlatformIO Core is a \emph{command line utility}\footnote{Panic not Windows users, the command line is not your mortal enemy. In fact, you can get stuff done a lot quicker in the command line, \emph{most} of the time. Once you get to know it of course.} which supplied the commands to initialise, create, compile, amend and upload code to your micro controller. 

The \program{PlatformIO IDE}PlatformIO IDE code is available to install into a number of editors and/or IDEs and allows you to use \index{PlatformIO}PlatformIO from within your editor or IDE. This option \emph{does not} require that the Core software be installed already, in fact, the IDE version will install the Core commands into your shell\footnote{Windows users - the shell is the Linux equivalent of your command line.} should you require this.

We shall be using the IDE option in this book, installed into the \program{Atom Editor}Atom editor.

\index{PlatformIO}PlatformIO allows you to create projects for your  \index{Arduino}Arduino, or, almost any other embedded micro controller that is known to man, woman or hamster! At the time of writing, 5th July 2017, \index{PlatformIO}PlatformIO supported:

\begin{itemize}
\item
  23 Development Platforms
\item
  13 Frameworks
\item
  412 Embedded Boards
\item
  61 Project Examples
\item
  1,738 Libraries
\item
  8,084 Library Examples
\end{itemize}

You can use it to replace the  \index{Arduino}Arduino IDE too, if you wish, as it understands plain  \index{Arduino}Arduino code as well as AVR C code.  \index{Arduino}Arduino sketches can be imported unchanged, worked on, compiled and uploaded without any difficulty.

As mentioned above, \index{PlatformIO}PlatformIO comes in two main flavours:

\begin{itemize}
\item
  The command line version\footnote{See previous footnote!} - also known as \program{PlatformIO Core}PlatformIO Core.
\item
  An IDE version for the \program{Atom Editor}Atom editor, or Visual Studio. This also allows   you to run the command line commands without having to install that   package separately.
\end{itemize}

In addition, there's a lot of documentation on the web site about how you can install the \index{PlatformIO}PlatformIO tools into a large number of different IDEs, some of which you may already be using.

\subsection{Installing Atom}\label{installing-atom}

As a lot of Windows people \emph{might} not be fully acquainted with the command line, I've decided to base the remainder of this book on using the \program{Atom Editor}Atom editor from Github, and the \emph{PlatformIO IDE}\program{PlatformIO IDE} package for it. However, I will explain the Core features, for those of us who want to use our own editor, for example.

Installing is simple. Go to \href{https://atom.io}{https://atom.io} where you will be presented with a download link for your operating system. If that is suitable, click it, otherwise choose the `Other Platforms' link and pick the best option from the list. It's best to be wary of the pre-release versions, stick with the current versions instead.

Windows users will get an installer. Linux users will get a package, rpm, deb for example, which can be installed with the default package manager.

That's pretty much all there is to it.

\subsection{Installing PlatformIO in Atom}\label{installing-platformio-in-atom}

We will install the following 2 PlatformIO packages for \program{Atom Editor}Atom:

\begin{itemize}
\item
  platformio-ide (version 2.0.0 beta 7 is the latest at the time of
  writing)
\item
  platformio-ide-debugger (version 1.2.3 is the latest at the time of
  writing)
\end{itemize}

Open \program{Atom Editor}Atom and select the \inline{Edit$\rightarrow$Preferences} menu option. When the \inline{Settings} tab appears, look down to find the option labelled \inline{+Install} and choose it.

Search for \inline{platformio} and a list of available options will soon be displayed. Find the two packages mentioned above and click the \inline{install} button. Wait \ldots{}.

Eventually you will be prompted to restart \program{Atom Editor}Atom, so do so.

If, on the restart, you are prompted to Install Clang go ahead and do so, if you wish, or select \inline{Disable Code Completion}. Clang will have to be installed using your package manager - it's not a package for \program{Atom Editor}Atom but for the entire system. Full details are \href{http://docs.platformio.org/en/latest/ide/atom.html\#ii-clang-for-intelligent-code-completion}{here}.

Full instructions on installing \program{Atom Editor}Atom and \index{PlatformIO}PlatformIO packages can be found \href{http://docs.platformio.org/en/latest/ide/atom.html\#clang-for-intelligent-code-completion}{here}.

You will know that you have installed \index{PlatformIO}PlatformIO when you restart \program{Atom Editor}Atom and see a `bug face' looking back at you from the \index{PlatformIO}PlatformIO welcome screen - this is the PlatformIO Home page.

\subsection{Installing Shell Commands}\label{installing-shell-commands}

Should you wish to install the \program{PlatformIO Core}PlatformIO Core commands for your system, then:

\begin{itemize}
	\item Click the \index{PlatformIO}PlatformIO menu item;
	\item Click Install Shell Commands option.
\end{itemize}

Hopefully, that will all work, however, as it uses the \inline{sudo} command, it \emph{may} fail to execute properly if your version of \inline{sudo} requires a password. However, \index{PlatformIO}PlatformIO helpfully displays the two commands that need to be executed in a shell session to enable the shell commands:

\begin{lstlisting}[caption={Install PlatformIO Shell Commands Manually}]
sudo ln -s /home/<yourname>/.platformio/penv/bin/platformio /usr/local/bin/platformio

sudo ln -s /home/<yourname>/.platformio/penv/bin/pio /usr/local/bin/pio
\end{lstlisting}

\emph{Obviously} you will have to replace <your name> as appropriate, but \index{PlatformIO}PlatformIO will display the correct commands for you to type in. When you do enter them, you will have to supply your \inline{sudo} password.

Once complete, you will have two new commands, \inline{pio} and \inline{platformio} - which are both the same, the former is pretty much a shortcut for the latter.

\begin{note}
	I have not run this on a Windows system, so I cannot guarantee that the option will be available, sorry.
\end{note}

\section{PlatformIO Quick Start}\label{platformio-quick-start}

\subsection{Create the Arduino Blink Project}\label{create-the-arduino-blink-project}

I mentioned previously, somewhere, that \index{PlatformIO}PlatformIO can import plain  \index{Arduino}Arduino projects. In fact, it has quite a number of the  \index{Arduino}Adruino examples available. To start with, we will create the Arduino Blink program - after all, that's where everyone starts, isn't it?

Open the \program{Atom Editor}Atom editor, if not already open, and click \inline{PlatformIO$\rightarrow$Project Examples}. You will be notified, on the first occasion, that internet access will be required.

In the drop down list, find, and select \inline{atmelavr/arduino-blink} and it will be added to the list of examples that will be installed. You can install more than one, but for now, stick with the one example.\footnote{If you go to \url{https://github.com/platformio/platformio-examples/archive/develop.zip} you can download the set of examples for a number of platforms.}

Click the \inline{prepare} button. After a very brief pause, you should notice that the project window has changed and a new folder named \inline{arduino-blink} appears there. Open up the \inline{src} folder and double-click on the file \inline{Blink.cpp} which you should find there.

You will see something like the following:\listing{ArduinoBlink.cpp}

\lstinputlisting[language=C,caption={Arduino Blink Example},label={lst-arduino-blink.cpp}]{AVRCode/Part1/PlatformIO_Quick_Start/ArduinoBlink.cpp}

Looks familiar? It should do, it's simply the Arduino Blink example code, with one minor difference, the inclusion of the \inline{Arduino.h} header file.

You can compile and upload the example code as follows:

\begin{itemize}
	\item Click \inline{PlatformIO$\rightarrow$Build}, or press \inline{CTRL+ALT+B}, or click the ``\checkmark'' in the boxes at the far left of the window - all of these will compile the code.
	
	\item Click \inline{PlatformIO$\rightarrow$Upload}, or press \inline{CTRL+ALT+U}, or click the ``$\Rightarrow$'' in the boxes at the far left of the window - all of these will upload the compiled code to your micro controller.
\end{itemize}

When the compilation is done, press F8 if the compilation log is not visible at the bottom of the screen.

\begin{lstlisting}[numbers={none},caption={Arduino Blink Memory Usage}]
AVR Memory Usage
----------------
Device: atmega328p

Program:     928 bytes (2.8% Full)

(.text + .data + .bootloader)

Data:          9 bytes (0.4% Full)
(.data + .bss + .noinit)
\end{lstlisting}

You will note, hopefully, that the example code is using a total of 928 bytes, plus a further 9 bytes for some data. I make that 937 bytes in total.

Keep a note of that figure for later\ldots{}.

\subsection{Create the AVR Blink Project}\label{create-the-avr-blink-project}

Open the \program{Atom Editor}Atom editor, if not already running, and make sure that you can see the PlatformIO Home Screen. Click on \inline{+ New Project} to start the New Project Wizard. Alternatively, click \inline{PlatformIO$\rightarrow$Initialize or Update PlatformIO Project}.

If the PlatformIO Home Screen is not visible, click \inline{PlatformIO$\rightarrow$PlatformIO Home} to make it visible.

You must first select a board. As I'm using an Arduino Nano with an \index{ATmega328P}ATmega328P micro controller, for this example, that's what I'll be selecting. You may choose something different.

You will hopefully notice that when you have selected a board, you get to select another, and another \ldots{}. this is a feature of PlatformIO in that it allows you to use the same source code for multiple boards and/or microcontrollers. This is very nice as I sometimes build for the Nano, the Uno, the Duemilenova and for the stand-alone \index{ATtiny85}ATtiny85 - so I can pretty much use the same code for all of the above. (The \index{ATtiny85}ATtiny85 needs a few \inline{\#define}s to compile the same code though!)

For now, however, let's stick with a single board.

Now select a directory to save the code in. My choice is:

 \inline{/home/norman/SourceCode/PlatformIO/AVRBlink}

you might want to choose something different, especially if you are on
Windows!

\begin{note}
You can obtain the source code, but not the \index{PlatformIO}PlatformIO project files etc, for all the examples in this book from \href{https://github.com/NormanDunbar/AVRBook}{GitHub} - look for the folder named \inline{SourceCode}. The code will be found in the same part and/or chapter as the book.
\end{note}

Click the `Process' button.

The first time \index{PlatformIO}PlatformIO is used, it needs to connect to the internet to install the appropriate tools for the board you have chosen. In the case of the Nano, this is \inline{platform: atmelavr}. Just wait while it does what it needs to do.

When the processing has completed, the output directory that you chose
above will be populated by a number of files and directories:

\begin{itemize}
\item
  A directory named \inline{lib} and a file, \inline{readme.txt} within.
  The README file has all the information you will need if you intend to
  write some libraries for this particular project. The source code for
  the libraries should be kept in this directory - with a separate directory for each separate library.
\item
  A directory named \inline{src}. This is where you will create your own
  project's source code.
\item
  A file named \inline{.gitignore}. This (hidden on Linux) file tells git, if in use for
  version control, to ignore a number of files that are not required in
  normal circumstances, usually files that can be recreated at will.
\item
  A file named \inline{.travis.yml}. This (hidden on Linux) file is a YAML source file that
  tells the Travis `Continuous Integration' system what to do whenever
  something in the project changes. We will not be using this feature.
\item
  A file named \inline{platformio.ini}. This file tells PlatformIO how the
  project will be built and uploaded to the microcontroller, for each
  board you selected when creating the project.
\end{itemize}

\subsection{Write the Blink Code}\label{write-the-blink-code}

Now we have our project (AVRBlink) created, we need to write some code, so:

\begin{itemize}
\item
  Right-click the \inline{src} folder in the \inline{Project} tab, and select
  \inline{New File} from the context menu that appears.
\item
  Enter the file name when prompted, I chose \inline{AVRBlink.c}, but you can name
  the file as you wish.
\end{itemize}

The new file opens in the editor, so add the following code:\listing{AVRBlink.c}

\lstinputlisting[language=C,caption={AVRBlink.c - AVR Blink Example},label={lst-avrblink.c}]{AVRCode/Part1/PlatformIO_Quick_Start/AVRBlink.c}

Save the file, \inline{File$\rightarrow$Save} or \inline{Ctrl-S}, then select
\inline{PlatformIO$\rightarrow$Build} or \inline{Ctrl-Alt-B} to build the program. The
compiler messages will appear, and then vanish after a couple of
seconds. Click \inline{PlatformIO$\rightarrow$Toggle Build Panel} or press F8
to display them again.

\begin{lstlisting}[numbers={none},caption={AVR Blink Memory Usage}]
AVR Memory Usage
----------------
Device: atmega328p

Program:     178 bytes (0.5% Full)

(.text + .data + .bootloader)

Data:          0 bytes (0.0% Full)
(.data + .bss + .noinit)\end{lstlisting}

You will note, hopefully, that this AVR example code is only using 178 bytes of code, and no data. I make that around one fifth (20\%) of the  \index{Arduino}Arduino example's 937 bytes in total.

You may be wondering why we wrap the setting of \inline{F\_CPU} in the following manner:

\begin{lstlisting}[language=C,firstnumber=2,caption={Wrapping F\_CPU in AVRBlink.c}]
#ifndef F_CPU
#define F_CPU 16000000UL // 16 MHz clock speed
#endif
\end{lstlisting}

This is because \index{PlatformIO}PlatformIO knows that an Arduino Nano with an \index{ATmega328P}ATmega328P runs with a 16MHz crystal, so it defines the correct speed for us. This is defined in the file:

\fbox{\inline{/home/norman/.platformio/packages/framework-arduinoavr/boards.txt}}

Well, it is for me anyway, your mileage may vary, where a number of other details are defined to make the system aware of the device, the speeds, baud rates for uploads etc.

If we are using something like \program{Atmel Studio}Atmel Studio, then that might not set it correctly, so the correct setting would be applied there, as well as here.

\subsection{Gosh, Look How Small it is!}\label{gosh-look-how-small-it-is}

Looking at the last few lines of the compiler output text for the \inline{AVRBlink.c} example, we see the following, which you may remember from above:

\begin{lstlisting}[firstnumber=14]
AVR Memory Usage
----------------
Device: atmega328p

Program:     178 bytes (0.5% Full)
(.text + .data + .bootloader)

Data:          0 bytes (0.0% Full)
(.data + .bss + .noinit)
\end{lstlisting}

This is telling you that the entire blink program takes up \emph{only}
178 bytes of Flash Memory and zero bytes of data space (in the Dynamic
RAM), on the Nano.  Can we get it any smaller? Try this:\listing{AVRBlinkSmall.c}

\lstinputlisting[language=C,caption={AVRBlinkSmall.c - A Smaller Blink Example}]{AVRCode/Part1/PlatformIO_Quick_Start/AVRBlinkSmall.c}


Compiling the above, results in this at the end:

\begin{lstlisting}[firstnumber=14]
AVR Memory Usage
----------------
Device: atmega328p

Program:     158 bytes (0.5% Full)

(.text + .data + .bootloader)

Data:          0 bytes (0.0% Full)
(.data + .bss + .noinit)
\end{lstlisting}

So, that's another 20 bytes off the total size just by using a trick of the AVR micro controller.

The trick? If you write a 1 to a pin configured as output, via the \inline{PINx} register, the pin will toggle each time you write it. This means, to flash an LED 4 times, you would toggle the pin 8 times - once on and once off is a single flash.

\begin{note}
	You will not be surprised to hear that this is pretty much the last time we will be using the \inline{\_delay\_ms()} functions, unless there's no option, these are classed as ``busy wait'' delays - they burn CPU cycles in a loop to give the desired delays. We need a better method. More on that later, but think \emph{timers}.
\end{note}

\subsection{Upload to Our Board}\label{upload-to-our-board}

Uploading to the board can be either through a USB cable, as we do with the  \index{Arduino}Arduino software, or, using an ISP programmer and the 6 pins on the  \index{Arduino}Arduino board. Which is best?

By default, \index{PlatformIO}PlatformIO assumes that you will be using a USB cable, so the file \inline{platformio.ini} is already suitable, and when you come to upload, the desired port will (or should) be detected automatically.

If you are using an \index{ISP Programmer}ISP programmer instead of the USB cable, then you must update the\\ \inline{platformio.ini} file to tell it which programmer you are using and the protocol. In addition, to upload firmware using an ISP programmer, you need to use \inline{target = program} instead of \inline{target = upload} - which is the default. 

You will need to add \inline{target = program} to your \inline{platformio.ini} file. Don't forget to save it before attempting to upload/program!\footnote{Yes, I forgot!} When you next attempt an upload, you will see the text \inline{target: program} at the very top of the compile/upload listing when you press F8.


Here are a few configurations for various programmers, taken from the \href{http://docs.platformio.org/en/latest/platforms/atmelavr.html?highlight=usbtiny#upload-using-programmer}{PlatformIO docs}. Add the following lines to your \inline{platformio.ini} file for the corresponding programmer:

\begin{lstlisting}[caption={The \inline{platformio.ini} additions for `AVRISP' ISP Programmer}]
    upload_protocol = stk500v1
    upload_flags = -P$UPLOAD_PORT

    ; edit this line with valid upload port
    upload_port = SERIAL_PORT_HERE
\end{lstlisting}


\begin{lstlisting}[caption={The \inline{platformio.ini} additions for `AVRISP MkII' Programmer}]
    upload_protocol = stk500v2
    upload_flags = -Pusb
\end{lstlisting}


\begin{lstlisting}[caption={The \inline{platformio.ini} additions for `USBTinyISP' Programmer}]
    upload_protocol = usbtiny
\end{lstlisting}


\begin{lstlisting}[caption={The \inline{platformio.ini} additions for `ArduinoISP` Programmer}]
    upload_protocol = arduinoisp
\end{lstlisting}


\begin{lstlisting}[caption={The \inline{platformio.ini} additions for `USBasp' ISP Programmer}]
    upload_protocol = usbasp
    upload_flags = -Pusb
\end{lstlisting}


\begin{lstlisting}[caption={The \inline{platformio.ini} additions for `Parallel Port' ISP Programmer}]
    upload_protocol = dapa
    upload_flags = -F
\end{lstlisting}


\begin{lstlisting}[caption={The \inline{platformio.ini} additions for `Arduino as ISP` Programmer}]
    upload_protocol = stk500v1
    upload_flags = -P$UPLOAD_PORT -b$UPLOAD_SPEED

    ; edit these lines
    upload_port = SERIAL_PORT_HERE
    upload_speed = 19200
\end{lstlisting}

The latter one is used when you have a spare  \index{Arduino}Arduino lying around doing nothing, and you have set it up to be used as an ISP programmer for AVR chips that don't have a bootloader, or simply because you want to! There will be more of this matter soon.

\begin{warning}
You should also be aware that if you \emph{ever} program an  \index{Arduino}Arduino using the \index{ISPProgrammer}ISP programmer, you cannot subsequently use the USB cable and bootloader until you have burned the bootloader back into the chip. Ask me how I know! 

The steps to do this are simple:

\begin{itemize}
\item Connect your USB cable to the  \index{Arduino}Arduino and to your computer.
\item Open the  \index{Arduino}Arduino IDE.
\item Ensure that your board and port are correctly defined under \inline{tools$\rightarrow$board}.
\item Ensure that the programmer is set to AVRisp MK II (or AVR isp).
\item Select \inline{Tools$\rightarrow$Burn bootloader}.
\end{itemize}

After a few flashes of the built in LED, the bootloader will have been burned back into the chip. 
\end{warning}

The first time we do this with an AVR device,  \index{Arduino}Arduino etc, we will need to download the \inline{avrdude} tool. This is what we need to program our device.

Select \inline{PlatformIO$\rightarrow$upload} and wait\ldots{}

Press F8 if the build information vanishes again.

You might see the following, on Linux:

\begin{lstlisting}
Warning! Please install `99-platformio-udev.rules` and check that your board's PID and VID are listed in the rules.
https://raw.githubusercontent.com/platformio/platformio/develop/scripts/99-platformio-udev.rules
\end{lstlisting}

(The filename above is all on one line, I've split it to fit on the page.)

This is required to allow non-root users on a Linux system, the ability
to upload using the USB ports. 

On some systems you might need to add your 
user to the group \inline{dialout} or possibly \inline{plugdev} and 
restart your \program{Atom Editor}Atom session to pick up the new group. You can find the correct group
as follows:

\begin{lstlisting}[language=bash]
grep -i -e dialout -e plugdev /etc/group

dialout:x:18:
\end{lstlisting}

In my case, on Centos 7, it's the \inline{dialout} group, so:

\begin{lstlisting}[language=bash]
sudo usermod -a -G dialout $USER
\end{lstlisting}


\subsubsection{Install the Rules File}\label{install-the-rules-file}

Download and install the rules file as follows:

\begin{lstlisting}[language=bash]
cd /tmp

# The following is all on ONE LINE!
sudo wget https://raw.githubusercontent.com/platformio/platformio/develop/scripts/99-platformio-udev.rules

sudo cp 99-platformio-udev.rules /etc/udev/rules.d/

sudo service udev restart
cd -
\end{lstlisting}

or, if that fails:

\begin{lstlisting}[language=bash]
sudo udevadm control --reload-rules
sudo udevadm trigger
cd -
\end{lstlisting}


